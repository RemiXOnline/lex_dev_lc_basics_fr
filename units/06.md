[&lt; Retour au sommaire](../README.md)

# Saisie de données à l'aide de formulaires (~ 35 min)
[Lien Trailhead](https://trailhead.salesforce.com/fr/modules/lex_dev_lc_basics/units/lex_dev_lc_basics_forms)

## Objectifs de formation
Une fois cette unité terminée, vous pourrez :
- Créer un formulaire affichant les valeurs actuelles et acceptant de nouvelles entrées de l’utilisateur.
- Lire des valeurs à partir des éléments du formulaire.
- Valider les entrées de l’utilisateur et afficher des messages d’erreur en cas d’entrée non valide.
- Refactoriser le code d’un contrôleur de composant dans son assistance.


## Saisie de données à l’aide de formulaires
Nous allons maintenant créer et assembler une mini application. Dans le cadre de notre apprentissage, nous nous intéresserons à un example d'application de suivi de dépenses aue nous nommerons "expenses". Nous passerons la plus grande partie de cette unité à créer et à comprendre le formulaire qui vous permet de créer une nouvelle dépense.

Notez toutefois que l'exercice pratique en fin d'unité continuera de porter sur l'application de gestion de materiel de camping.

## Le conteneur d’application expenses
La première chose que nous ferons, c’est invoquer le système Salesforce Lightning Design System, ou SLDS dans notre application. La manière dont nous le ferons permettra d’aborder un peu plus en détails les conteneurs d’applications.

Actuellement, SLDS est automatiquement accessible à vos composants lorsqu’ils sont exécutés dans Lightning Experience ou Salesforce1. Nous parlons parfois d’exécution dans le conteneur `one.app`. Cette version intégrée est la même que celle utilisée par de nombreux composants Lightning standard. Cependant, SLDS n’est pas accessible par défaut dans une application autonome, ou lorsque vous utilisez vos composants hors de Lightning ou des composants Lightning pour Visualforce. Ce sont des conteneurs d’application différents et ils offrent des services et ressources variés. Nous aimerions créer notre application expense de manière à ce qu’elle fonctionne et s’affiche correctement dans tous ces contextes.

Nous le ferons en ajoutant SLDS à notre application de test. Ensuite, dans la « vraie » application expenses (le composant parent et tous ses descendants), nous pourrons utiliser les resources SLDS (feuilles de styles, icônes, etc.) sans nous soucier de leur provenance. Pour ainsi dire, notre conteneur d’application (l’application de test) configure les ressources dans son contexte de manière à ce que toute application s’exécutant dans ce conteneur dispose des ressources dont elle a besoin.

Transformons donc ces longs discours en un peu de code et créons notre nouvelle application Lightning `expensesApp.app` :
```xml
<aura:application extends="force:slds">

        <!-- This component is the real "app" -->
        <!-- c:expenses/ -->

</aura:application>
```

Voici ce qu’il se passe. L’attribut `extends="force:slds"` active SLDS dans cette application, en incluant les mêmes styles Lightning Design System que ceux fournis par Lightning Experience et Salesforce1. Mais notez que cette application test n’est qu’une enveloppe, une coquille. La "vraie" application est le composant `expenses`, que nous n’avons pas encore créé (c’est la partie `<!-- c:expenses/ -->`  commentée car nous ne pouvons pas enregistrer notre application tant que le composant `expenses` n’existe pas).

Grâce à l’application de test, nos composants utilisent le mécanisme `extends="force:slds"` pour accéder à SLDS lorsqu’ils s’exécutent à partir de cette application. Lorsqu’ils s’exécutent dans Lightning Experience ou Salesforce1, sans modification de code, ils utilisent cette inclusion automatique de SLDS du conteneur.


## Le composant d’application expenses
L’étape suivante consiste à créer un composant qui sera le niveau supérieur de notre application expenses (souvenez-vous, même si nous parlons d’une « application », il s’agit en fait seulement d’un composant Lightning). Dans la Developer Console, créez un nouveau composant Lightning `expenses` avec le code suivant.
```xml
<aura:component>
    <!-- PAGE HEADER -->
    <div class="slds-page-header" role="banner">
      <div class="slds-grid">
        <div class="slds-col">
          <p class="slds-text-heading--label">Expenses</p>
          <h1 class="slds-text-heading--medium">My Expenses</h1>
        </div>
      </div>
    </div>
    <!-- / PAGE HEADER -->

    <!-- NEW EXPENSE FORM -->
    <div class="slds-col slds-col--padded slds-p-top--large">


        <!-- [[ expense form goes here ]] -->


    </div>
    <!-- / NEW EXPENSE FORM -->

</aura:component>
```

Vous pouvez maintenant retirer les commentaires de la balise `<c:expenses/>` dans l'application `expensesApp.app` et ouvrir l’aperçu de ce qui n’est - pour l’instant - qu’une coquille vide. Vous devriez obtenir un aperçu comme suit.

<img src="https://res.cloudinary.com/hy4kyit2a/image/upload/doc/trailhead/fr-fr56b1260103ed9182d9cb8531390505b9.png"/>

Pour l’instant il ne se passe pas grand-chose mais nous pouvons déjà constater l'injection du style SLDS.


## Le formulaire New Expense
Dans un premier temps, nous alons créer le formulaire dans un seul et même composant. Notez que cela va à l'encontre des bonnes pratiques qui prône la décomposition des interfaces mais cela va nous faire gagner du temps pour cet exemple.

Dans le composant expenses, remplacez le commentaire `<!-- [[ expense form goes here ]] -->` par le code suivant pour ajouter le formulaire "Add Expense" :
```xml
  <div aria-labelledby="newexpenseform">

  <!-- BOXED AREA -->
  <fieldset class="slds-box slds-theme--default slds-container--small">

    <legend id="newexpenseform" class="slds-text-heading--small 
      slds-p-vertical--medium">
      Add Expense
    </legend>

    <!-- CREATE NEW EXPENSE FORM -->
    <form class="slds-form--stacked">

      <div class="slds-form-element slds-is-required">
          <div class="slds-form-element__control">
              <ui:inputText aura:id="expname" label="Expense Name"
                  class="slds-input"
                  labelClass="slds-form-element__label"
                  value="{!v.newExpense.Name}"
                  required="true"/>
          </div>
     </div>

     <div class="slds-form-element slds-is-required">
          <div class="slds-form-element__control">
              <ui:inputNumber aura:id="amount" label="Amount"
                  class="slds-input"
                  labelClass="slds-form-element__label"
                  value="{!v.newExpense.Amount__c}"
                  required="true"/>

          </div>
      </div>

      <div class="slds-form-element">
          <div class="slds-form-element__control">
              <ui:inputText aura:id="client" label="Client"
                  class="slds-input"
                  labelClass="slds-form-element__label"
                  value="{!v.newExpense.Client__c}"
                  placeholder="ABC Co."/>
          </div>
      </div>

      <div class="slds-form-element">
          <div class="slds-form-element__control">
              <ui:inputDate aura:id="expdate" label="Expense Date"
                  class="slds-input"
                  labelClass="slds-form-element__label"
                  value="{!v.newExpense.Date__c}"
                  displayDatePicker="true"/>
          </div>
      </div>

      <div class="slds-form-element">
          <ui:inputCheckbox aura:id="reimbursed" label="Reimbursed?"
              class="slds-checkbox"
              labelClass="slds-form-element__label"
              value="{!v.newExpense.Reimbursed__c}"/>
      </div>

      <div class="slds-form-element">
          <ui:button label="Create Expense"
              class="slds-button slds-button--brand"
              press="{!c.clickCreateExpense}"/>
      </div>

    </form>
    <!-- / CREATE NEW EXPENSE FORM -->

  </fieldset>
  <!-- / BOXED AREA -->

</div>
<!-- / CREATE NEW EXPENSE -->
```

Cela paraît faire beaucoup de code à assimiler en une fois. Ce n’est pas le cas. En retirant le balisage et les classes SLDS, d’un point de vue composants Lightning, ce formulaire se résume en fait à ce qui suit :
```xml
<ui:inputText aura:id="expname" label="Expense Name"
    value="{!v.newExpense.Name}" required="true"/>

<ui:inputNumber aura:id="amount" label="Amount"
    value="{!v.newExpense.Amount__c}" required="true"/>

<ui:inputText aura:id="client" label="Client"
    value="{!v.newExpense.Client__c}" placeholder="ABC Co."/>

<ui:inputDate aura:id="expdate" label="Expense Date"
    value="{!v.newExpense.Date__c}" displayDatePicker="true"/>

<ui:inputCheckbox aura:id="reimbursed" label="Reimbursed?"
    value="{!v.newExpense.Reimbursed__c}"/>

<ui:button label="Create Expense" press="{!c.clickCreateExpense}"/>
```

Voici le formulaire obtenu.

<img src="https://res.cloudinary.com/hy4kyit2a/image/upload/doc/trailhead/fr-fr3df7ec076649e15f979c9a3e2c8624c0.png" width="50%"/>

Il n’y a que cinq composants d’entrée et un bouton. Nous avons déjà étudié les boutons, alors parlons des quelques nouveaux éléments de ces composants d’entrée.

Pour commencer, remarquez que nous disposons de divers composants d’entrée, et qu’ils sont nommés de manière à suggérer qu’ils seront les mieux adaptés à des types de données spécifiques. Par exemple, vous ne serrez pas surpris d’apprendre qu’il faudra utiliser `<ui:inputDate>` pour un champ de date, etc. Il y a toute une gamme de composants d’entrée différents, bien au-delà des quatre qui se trouvent ici, et il est toujours préférable d’associer le type de composant au type de données. La raison ne vous semble peut-être pas encore évidente, mais elle le deviendra lorsque vous essaierez cette application sur un téléphone : les composants offrent des gadgets d’entrée parfaitement adaptés au format. Par exemple, le sélecteur de date est optimisé pour une entrée à la souris ou au doigt, selon l’appareil sur lequel vous y accédez.

Ensuite, remarquez qu’un libellé est défini pour chaque composant, et que le texte de `label` est automatiquement affiché à côté du champ d’entrée. Il y a quelques autres attributs que nous n’avons pas encore rencontrés auparavant : `required`, `placeholder` et `displayDatePicker`. Si vous ne parvenez pas à deviner ce qu’ils sont, vous pouvez les rechercher (nous reviendrons à ce terme trompeur `required`).

Il y a aussi un attribut `aura:id` défini dans chaque balise. À quoi sert-il ? Il définit un ID unique (localement) pour chaque balise à laquelle il est ajouté, et c’est cet ID qui vous permettra d’extraire les valeurs des champs du formulaire. Nous allons bientôt découvrir comment procéder.


## Attributs des objets Salesforce (sObjects)
Mais nous devons d’abord nous intéresser à l’attribut `value`. Chaque balise a une valeur configurée comme une expression. Par exemple `{!v.newExpense.Amount__c}`. D’après le format de l’expression, vous pouvez déduire plusieurs éléments.

- `v` signifie que c’est une propriété du fournisseur de valeur de la vue. Cela signifie qu’il s’agit d’un attribut du composant (que nous n’avons pas encore créé).
- La notation pointée indique que `newExpense` est un type de données structuré. Cela signifie que `newExpense` a ses propres propriétés.
- Le `__c` final que l’on retrouve dans la plupart des noms de propriétés permet de deviner qu’elles renvoient à des champs personnalisés, vraisemblablement dans l’objet personnalisé `Expense`.
- Par conséquent, `newExpense` est sans doute un objet `Expense` !

Nous ne l'avons pas encore ajouté. Voici une définition d’attribut que vous devez ajouter en haut du composant, juste après la balise d’ouverture `<aura:component>`.
```xml
<aura:attribute name="newExpense" type="Expense__c"
     default="{ 'sobjectType': 'Expense__c',
                    'Name': '',
                    'Amount__c': 0,
                    'Client__c': '',
                    'Date__c': '',
                    'Reimbursed__c': false }"/>
```

Ce qu’elle fait est assez simple. Vous connaissez déjà l’attribut `name`. Et pas de surprise, le `type` correspond au nom de l’API de notre objet personnalisé. Jusqu’ici, tout va bien.

L’attribut `default` n’est pas nouveau, à la différence du format de sa valeur. Mais ça ne devrait pas être trop compliqué à comprendre. C’est une représentation JSON d’un sObject, qui spécifie le type d’objet (le nom de l’API) et les valeurs de chacun des champs qui lui sont attribués par défaut. Dans notre cas, nous configurons tout pour représenter une valeur vide.

Et c’est à peu près tout ce que vous devez savoir sur les sObjects ! À partir de là, l’infrastructure des composants Lightning vous laissera traiter `newExpense` en JavaScript et dans son balisage, comme si c’était un enregistrement Salesforce, même si nous ne le chargeons pas (encore) depuis Salesforce !


## Traitement de la soumission d’un formulaire avec un gestionnaire d’action



## Défi pratique
Nous allons créer un formulaire pour ajouter du matériel.
Pour ce faire, appliquez le style SLDS aux composants.
Modifiez `campingList`:
- Placez le titre H1 dans une balise avec une classe `slds-page-header`.
- Ajoutez un composant formulaire similaire à l’exemple.
- Ajoutez un attribut `items` de type liste de `Camping_Item__c`.
- Ajoutez un attribut `newItem` de type `Camping_Item__c` avec une quantité et un prix de 0 par défaut.
- Le composant affichera les valeurs des attributs `Name`, `Quantity`, `Price` et `Packed` de l’objet `newItem` dans des champs de saisie appropriés.
- Le contrôleur JavaScript s’assurera que les valeurs des attributs ne sont pas null.
- Si le formulaire est valide, le contrôleur ajoutera `newItem` à la liste `items` et réinitialisera l’objet `newItem` aux valeurs par défaut.

Validez votre travail automatiquement grâce au [défi Trailhead](https://trailhead.salesforce.com/fr/modules/lex_dev_lc_basics/units/lex_dev_lc_basics_forms#challenge) avant de passer à l'unité suivante.

---
[Unité suivante &gt;](07.md)
