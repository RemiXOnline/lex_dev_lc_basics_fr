[&lt; Retour au sommaire](../README.md)

# Connexion à Salesforce avec des contrôleurs côté serveur (~ 35 min)
[Lien Trailhead](https://trailhead.salesforce.com/fr/modules/lex_dev_lc_basics/units/lex_dev_lc_basics_server)

## Objectifs de formation
Une fois cette unité terminée, vous pourrez :
- Créer des méthodes Apex qui peuvent être appelées à distance par du code de composants Lightning.
- Créer des appels de méthode à distance depuis des composants Lightning.
- Traiter des réponses du serveur de manière asynchrone avec des fonctions de rappel.
- En bonus : expliquer la différence entre `c.`, `c:` et `c.`.


## Concepts de contrôleurs côté serveur
Jusqu’ici, tout ce que nous avons fait se trouvait strictement côté client. Il est temps d’ajouter des contrôleurs côté serveur à notre application pour enrigistrer nos objets.

Pour commencer, revoyons le premier schéma étudié dans ce module, un aperçu à (très) haut niveau de l’architecture des applications à composants Lightning.

<img src="02/lcf-architecture.png" width="75%"/>

Jusqu’à présent, tout ce que nous avons étudié se trouvait côté client (et notez que nous avons simplifié les choses en fusionnant les contrôleurs et assistances). Bien que nous ayons référencé un type d’objet personnalisé `Expense__c` qui est défini côté serveur, nous n’avons jamais vraiment touché directement au serveur.

Vous vous souvenez que nous avons parlé de relier les éléments ensemble pour établir un circuit complet ? Le formulaire expenses que nous avons conçu lors de la dernière unité pourrait ressembler à ce qui suit :

<img src="https://res.cloudinary.com/hy4kyit2a/image/upload/doc/trailhead/fr-fr4283549c1bf23a647d6b2cf79d4c3ab3.png" width="75%"/>

Le circuit commence par le bouton **Créer** qui est relié au gestionnaire d’actions `clickCreate` (1). Lorsque ce gestionnaire d’actions s’exécute, il extrait les valeurs des champs de formulaire (2) puis ajoute une nouvelle dépense au tableau `expenses` (3). Lorsque le tableau est mis à jour via `set`, le nouveau rendu automatique de la liste des dépenses se déclenche (4).

Bon, lorsque nous câblons notre circuit pour l’accès côté serveur, le schéma devient un peu plus compliqué. Plus de flèches, plus de couleurs, plus de numéros (nous vous expliquerons tout cela plus tard) !

Lorsque nous ajoutons à cela l’accès côté serveur, le schéma devient un peu plus compliqué.

<img src="https://res.cloudinary.com/hy4kyit2a/image/upload/doc/trailhead/fr-fr570378df7a106c102d8303bec2f28eca.png" width="75%"/>

De plus, ce circuit ne permet pas la même démarche de contrôle régulière et synchrone. Les appels serveur sont coûteux en termes de ressources et de temps. Des millisecondes lorsque tout se passe bien, et de longues secondes en cas d’encombrement du réseau.

La solution pour que nos applications restent réactives tout en attendant ces réponses serveur consiste à les gérer de manière asynchrone. Cela signifie que lorsque vous cliquez sur le bouton « Créer dépense » (1), votre contrôleur côté client envoie une requête au serveur (4) en spécifiant une fonction nommée "callback" (3) puis continue le traitement (2). Non seulement il n’attend pas le serveur, mais oublie même qu’il a émis la requête !

Donc, lorsque la réponse du serveur revient (5), la fonction de callback s’exécute et la gère (6). La fonction se charge de la mise à jour des données côté client et de l’interface utilisateur.

Si vous êtes programmeur JavaScript expérimenté, l’exécution asynchrone et les fonctions de rappel font probablement partie de vos bases.


## Requête d’obtention de données Salesforce
Nous allons commencer par lire des données de Salesforce, ce qui nous permettra de charger la liste des dépenses existantes au démarrage de l’application Expenses.

**Note :** Si vous n’avez pas encore créé d'enregistrements de dépenses dans Salesforce, c’est le bon moment pour le faire. Sinon, une fois que vous aurez implémenté ce qui suit, vous pourriez vous retrouver à perdre du temps en vous demandant pourquoi rien ne se charge, alors que c’est en fait parce qu’il n’y a rien à charger.

La première étape consiste à créer votre contrôleur Apex. Les contrôleurs Apex contiennent des méthodes distantes que vos composants Lightning peuvent appeler. Dans ce cas précis, pour interroger Salesforce afin de recevoir les données des dépenses.

Examinons une version simplifiée du code. Sur la Developer Console, créez une nouvelle classe Apex nommée `ExpensesController` et collez-y le code suivant.
```java
public with sharing class ExpensesController {

    @AuraEnabled
    public static List<Expense__c> getExpenses() {
        return [SELECT Id, Name, Amount__c, Client__c, Date__c, Reimbursed__c, CreatedDate 
                FROM Expense__c];
    }
}
```

Nous aborderons les contrôleurs Apex de manière plus détaillée dans la prochaine section, mais pour le moment, la méthode Apex est vraiment très directe. Elle exécute une requête SOQL et retourne les résultats. Seuls deux éléments spécifiques rendent cette méthode accessible au code de vos composants Lightning.

- L’annotation `@AuraEnabled` figurant avant la déclaration de la méthode.
- Le mot clé `static`. Toutes les méthodes `@AuraEnabled` doivent être statiques, avec un scope `public` ou `global`.

« Aura » est le nom de l’infrastructure open source au cœur des composants Lightning. Vous avez pu observer son utilisation dans l’espace de noms pour certaines balises fondamentales, tells que `<aura:component>`. Vous savez maintenant d’où elle vient.

Point qui mérite d’être signalé : la méthode n’effectue aucune opération particulière pour empaqueter les données pour les composants Lightning. Elle se contente de retourner directement les résultats de la requête SOQL. L’infrastructure des composants Lightning gère tous les rassemblements / séparations impliqués dans la plupart des situations.


## Chargement des données de Salesforce
La prochaine étape consiste à relier le composant expenses au contrôleur Apex côté serveur. C’est si simple que vous risquez de sauter de joie. Modifiez la balise d’ouverture `<aura:component>` du composant expenses afin qu’elle pointe vers le contrôleur Apex, de la manière suivante :

```xml
<aura:component controller="ExpensesController">
```


## Défi pratique
Reprenons notre application de gestion de materiel de camping.
Nous allons créer un formulaire d'ajout de matériel avec le style SLDS.

Modifiez `campingList`:
- Placez le titre H1 dans une balise avec une classe `slds-page-header`.
- Ajoutez un composant formulaire similaire à l’exemple.
- Ajoutez un attribut `items` de type liste de `Camping_Item__c`.
- Ajoutez un attribut `newItem` de type `Camping_Item__c` avec une quantité et un prix de 0 par défaut.
- Le composant affichera les valeurs des attributs `Name`, `Quantity`, `Price` et `Packed` de l’objet `newItem` dans des champs de saisie appropriés.
- Le contrôleur JavaScript s’assurera que les valeurs des attributs ne sont pas null.
- Si le formulaire est valide, le contrôleur ajoutera `newItem` à la liste `items` et réinitialisera l’objet `newItem` aux valeurs par défaut.

Validez votre travail automatiquement grâce au [défi Trailhead](https://trailhead.salesforce.com/fr/modules/lex_dev_lc_basics/units/lex_dev_lc_basics_server#challenge) avant de passer à l'unité suivante.

**Note :** pour les besoins de la validation automatique, veillez à utiliser le contrôleur et à ne pas placer de code dans l'assistant (helper).

---
[Unité suivante &gt;](08.md)
